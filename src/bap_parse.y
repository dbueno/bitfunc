/*
 * Copyright 2012 Sandia Corporation. Under the terms of Contract
 * DE-AC04-94AL85000, there is a non-exclusive license for use of this work by
 * or on behalf of the U.S. Government. Export of this program may require a
 * license from the United States Government.
 */
/*

This is a lemon parser for the text version of the BAP intermediate language
(IL).

It's pretty simple. It assumes the lexer (we're using flex) discards all
comments from the input stream and otherwise uses the token names generated by
lemon.

Currently there are no actions, just parsing rules. The next step is to make it
do a symbolic simulation directly during parsing, instead of building up a big
AST and then doing it. But it might take some doing (e.g. there might be
intermediate AST nodes, though never a full AST).

*/

%token_type {bap_token *}
%extra_argument {bap_machine *MS}
%token_prefix BAP_TOK_
%token_destructor { destroy_token($$); }

%nonassoc EQUAL.
%nonassoc LET IN.
%nonassoc IF THEN ELSE.
%left WITH.
%nonassoc CONCAT.
%nonassoc EXTRACT.
%left OR.
%left XOR.
%left AND.
%left EQUALEQUAL NEQ.
%left LT SLT SLE LE GT GE SGT SGE.
%left LSHIFT RSHIFT ARSHIFT.
%left PLUS MINUS.
%left TIMES DIVIDE SDIVIDE MOD SMOD.
%left UMINUS NOT.
%nonassoc LSQUARE.

%include
{
#include <bitfunc/config.h>

#include <stdio.h>
#include <bitfunc.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <errno.h>
#include "bap_parse_types.h"

static int num_stmts = 0;

#define PROTECT if (!MS->has_error)
#define ERROR(...) do{ fprintf(stderr, "Machine error: "); fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); MS->has_error = true; }while(0)
#define WARNING(...) do{ fprintf(stderr, "Machine warning: "); fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); }while(0)



#define IS_BV(x) (x->typ.kind == BAP_TYPE_KIND_BV)
#define IS_MEM(x) (x->typ.kind == BAP_TYPE_KIND_MEM)
#define IS_ARRAY(x) (x->typ.kind == BAP_TYPE_KIND_ARRAY)
#define IS_STR(x) (x->typ.kind == BAP_TYPE_KIND_STR)

#define BV(x) (assert(IS_BV(x)), x->v.bv)
#define ARRAY(x) (assert(IS_ARRAY(x)), x->v.mem)
#define STR(x) (assert(IS_STR(x)), x->v.str)

#define BV_BINOP(op, E, A, B) {if (!(IS_BV(A) && IS_BV(B))) { ERROR("BINOP arguments are not bvs"); } else { E = bap_val_new_bv(op(MS->bf, BV(A), BV(B))); bap_val_unref(MS, A); bap_val_unref(MS, B); }}
#define BV_CMPOP(op, E, A, B) {if (!(IS_BV(A) && IS_BV(B))) { ERROR("CMPOP arguemnts are not bvs"); } else { bitvec *v = bfvInit(MS->bf, 1); v->data[0] = op(MS->bf, BV(A), BV(B)); E = bap_val_new_bv(v); bap_val_unref(MS, A); bap_val_unref(MS, B); }}
#define BV_INVCMPOP(op, E, A, B) {if (!(IS_BV(A) && IS_BV(B))) { ERROR("INVCMPOP arguments are not bvs"); } else { bitvec *v = bfvInit(MS->bf, 1); v->data[0] = -op(MS->bf, BV(A), BV(B)); E = bap_val_new_bv(v); bap_val_unref(MS, A); bap_val_unref(MS, B); }}

#define CHECK_ISA(V, T) do{if (!bap_types_equal(&V->typ, &T)) { char *T_s = bap_describe_type(T); char *VT_s = bap_describe_type(V->typ); ERROR("value does not match type. Got %s, expected %s", T_s, VT_s); free(T_s); free(VT_s); }}while(0)

extern inline bitvec *myAdd0(bfman *m, bitvec *x, bitvec *y) { return bfvAdd(m, x, y, LITERAL_FALSE, NULL); }

/* make sure destroy_token is in the object file: */
extern void destroy_token(bap_token *tok);

bap_val *do_function(bap_machine *MS, char *f, bap_type t, bap_val *arg) {
  if (!strcmp(f, "pad")) {
    if (t.kind != BAP_TYPE_KIND_BV) {
      ERROR("pad result type is not bv");
    } else if (!IS_BV(arg)) {
      ERROR("pad argument is not a bv");
    } else {
      return bap_val_new_bv(bfvZextend(MS->bf, t.val_width, BV(arg)));
    }
  } else if (!strcmp(f, "extend")) {
    if (t.kind != BAP_TYPE_KIND_BV) {
      ERROR("extend result type is not bv");
    } else if (!IS_BV(arg)) {
      ERROR("extend argument is not a bv");
    } else {
      return bap_val_new_bv(bfvSextend(MS->bf, t.val_width, BV(arg)));
    }
  } else if (!strcmp(f, "low")) {
    if (t.kind != BAP_TYPE_KIND_BV) {
      ERROR("low result type is not bv");
    } else if (!IS_BV(arg)) {
      ERROR("low argument is not a bv");
    } else {
      return bap_val_new_bv(bfvTruncate(MS->bf, t.val_width, BV(arg)));
    }
  } else if (!strcmp(f, "high")) {
    if (t.kind != BAP_TYPE_KIND_BV) {
      ERROR("high result type is not bv");
    } else if (!IS_BV(arg)) {
      ERROR("high argument is not a bv");
    } else {
      return bap_val_new_bv(bfvExtract(MS->bf, BV(arg), 0, t.val_width));
    }
  }
  ERROR("Unsupported function %s\n", f);
  return NULL;
}

}

%syntax_error {
  fprintf(stderr, "Syntax error near %d:%d!\n", -1, -1);
}

%parse_failure {
  fprintf(stderr, "Parse failed\n");
}

%parse_accept {
  fprintf(stderr, "Found %d statements.\n", num_stmts);
}

program ::= stmts.
program ::= error UNEXPECTED(E). { printf("Unexpected %s at line %u col %u\n", E->ident, E->line, E->col); }
program ::= error UNTERMINATED_STRING. { printf("Unterminated string literal\n"); }
stmts ::= .
stmts ::= stmts stmt. {num_stmts++;}

stmt ::= JMP expr attrs semi. { WARNING("JMP not supported"); }
stmt ::= CJMP expr(E) COMMA expr COMMA expr attrs semi. { bfvPush(MS->path_constraints, E->v.bv->data[0]); /* ERROR("CJMP not supported"); */ }
stmt ::= SPECIAL STRING attrs semi. { WARNING("SPECIAL not supported"); }
stmt ::= lval(L) ASSIGN expr(V) attrs semi. { CHECK_ISA(V, L.typ); PROTECT { bap_set_binding(MS, L.name, V); free(L.name); bap_val_unref(MS, V); } }
stmt ::= lval(L) EQUAL expr(V) attrs semi. { CHECK_ISA(V, L.typ); PROTECT { bap_set_binding(MS, L.name, V); free(L.name); bap_val_unref(MS, V); } }
stmt ::= HALT expr attrs semi. { PROTECT { MS->halted = true; } }
stmt ::= ASSERT(A) expr(E) attrs semi.  {
  PROTECT { 
    bfstatus st = bfCheckStatus(MS->bf, BV(E)->data[0]);
    switch (st) {
      case STATUS_MUST_BE_FALSE:
        ERROR("Assertion failed at line %u col %u", A->line, A->col);
        break;
      case STATUS_NOT_TRUE_NOR_FALSE:
        ERROR("not true or false! %u %u", A->line, A->col);
        break;
      case STATUS_UNKNOWN:
        ERROR("unknown! %u %u", A->line, A->col);
        break;
      case STATUS_MUST_BE_TRUE:
        bfPushAssumption(MS->bf, BV(E)->data[0]);
        break;
      case STATUS_TRUE_OR_FALSE:
        bfvPush(MS->path_constraints, E->v.bv->data[0]); 
        break;
    }
    bap_val_unref(MS, E);
    destroy_token(A);
  }
}
stmt ::= LABEL ID(I) attrs. { /* fprintf(stderr, "==%s==\n", I->ident); */ destroy_token(I); }
stmt ::= ADDR INT(I) attrs. { /* fprintf(stderr, "==0x%" PRIxMAX"===\n", I->i); */ destroy_token(I); }
stmt ::= comment attrs. { }

comment ::= BLKCOMMENT_START blkcomment. { }
comment ::= LINECOMMENT. { }

blkcomment ::= blkcomment BLKCOMMENT_CHUNK. { }
blkcomment ::= . { }

%type plusminusint { intmax_t }

plusminusint(R) ::= INT(I). { R = I->i; destroy_token(I); }
plusminusint(R) ::= MINUS INT(I). { R = -I->i; destroy_token(I); }

context ::= ID LSQUARE INT RSQUARE EQUAL INT COMMA plusminusint COMMA styp. { }
context ::= ID(I) EQUAL INT(V) COMMA plusminusint(T) COMMA typ(Y). { if (T == 0) { bap_set_binding(MS, I->ident, bap_val_new_bv(bfvUconstant(MS->bf, Y.val_width, V->i))); } destroy_token(V); destroy_token(I); }

attrs ::= . { }
attrs ::= attr attrs. { }

attr ::= AT ID STRING. { }
attr ::= AT ID context. { }

%type lval { bap_lval }
%destructor lval { free($$.name); }

lval(V) ::= ID(I) optyp(T). { V = (bap_lval) { .name = strdup(I->ident), .typ = T }; destroy_token(I); }

%type optyp { bap_type }

optyp(T) ::= . { T = (bap_type) { .flags = 0 }; }
optyp(T) ::= COLON typ(U). { T = U; }

%type typ { bap_type }

typ(T) ::= styp(U). { PROTECT { T = (bap_type) { .idx_width = 0, .val_width = U, .flags = BAP_TYPE_FLAG_VALID, .kind = BAP_TYPE_KIND_BV }; } }
typ(T) ::= QUESTION styp(U). { PROTECT { T = (bap_type) { .idx_width = 0, .val_width = U, .flags = BAP_TYPE_FLAG_VALID, .kind=  BAP_TYPE_KIND_MEM }; } }
typ(T) ::= styp(U) QUESTION styp(V). { PROTECT { T = (bap_type) { .idx_width = V, .val_width = U, .flags = BAP_TYPE_FLAG_VALID, .kind = BAP_TYPE_KIND_ARRAY }; } }

%type styp { uint8_t }
styp(S) ::= ID(I).  {
                      if (!strcmp(I->ident, "bool")) {
                        S = 1;
                      } else if (I->ident[0] == 'u' && I->ident[1] != 0) {
                        unsigned long int iv;
                        char *end;
                        errno = 0;
                        iv = strtoul(&I->ident[1], &end, 10);
                        if (errno != 0 || *end != 0) {
                          ERROR("Unknown type %s\n", I->ident);
                        }
                        S = (uint8_t)iv;
                      } else {
                        ERROR("Unknown type %s\n", I->ident);
                      }
                      destroy_token(I);
                    }

%type letstart {letctx}
letstart(L) ::= LET ID(I) COLON typ(T) ASSIGN expr(V). { CHECK_ISA(V, T); PROTECT { L = (letctx) { .name = strdup(I->ident), .val = bap_val_ref(MS, bapSymbolSearch(MS->bindings, I->ident)) }; bap_set_binding(MS, I->ident, V); } destroy_token(I); bap_val_unref(MS, V); }

%type expr {bap_val *}
%destructor expr { bap_val_unref(MS, $$); }

expr(E) ::= LPAREN expr(A) RPAREN. { PROTECT { E = A; } }
expr(E) ::= expr(A) PLUS expr(B). { PROTECT { BV_BINOP(myAdd0, E, A, B) } }
expr(E) ::= expr(A) MINUS expr(B). { PROTECT { BV_BINOP(bfvSubtract, E, A, B) } }
expr(E) ::= expr(A) TIMES expr(B). { PROTECT { BV_BINOP(bfvMul, E, A, B) } }
expr(E) ::= expr(A) DIVIDE expr(B). { PROTECT { BV_BINOP(bfvQuot, E, A, B) } }
expr(E) ::= expr(A) SDIVIDE expr(B). { PROTECT { (void)A; (void)B; (void)E; assert(0 && "denis needs to do this"); } }
expr(E) ::= expr(A) MOD expr(B). { PROTECT { BV_BINOP(bfvRem, E, A, B) } }
expr(E) ::= expr(A) SMOD expr(B). { PROTECT { (void)A; (void)B; (void)E; assert(0 && "denis needs to do this"); } }
expr(E) ::= expr(A) LSHIFT expr(B). { PROTECT { BV_BINOP(bfvLshift, E, A, B) } }
expr(E) ::= expr(A) RSHIFT expr(B). { PROTECT { BV_BINOP(bfvLRshift, E, A, B) } }
expr(E) ::= expr(A) ARSHIFT expr(B). { PROTECT { BV_BINOP(bfvARshift, E, A, B) } }
expr(E) ::= expr(A) AND expr(B). { PROTECT { BV_BINOP(bfvAnd, E, A, B) } }
expr(E) ::= expr(A) OR expr(B). { PROTECT { BV_BINOP(bfvOr, E, A, B) } }
expr(E) ::= expr(A) XOR expr(B). { PROTECT { BV_BINOP(bfvXor, E, A, B) } }
expr(E) ::= expr(A) EQUALEQUAL expr(B). { PROTECT { BV_CMPOP(bfvEqual, E, A, B) } }
expr(E) ::= expr(A) NEQ expr(B). { PROTECT { BV_INVCMPOP(bfvEqual, E, A, B) } }
expr(E) ::= expr(A) LT expr(B). { PROTECT { BV_CMPOP(bfvUlt, E, A, B) } }
expr(E) ::= expr(A) LE expr(B). { PROTECT { BV_CMPOP(bfvUlte, E, A, B) } }
expr(E) ::= expr(A) SLT expr(B). { PROTECT { BV_CMPOP(bfvSlt, E, A, B) } }
expr(E) ::= expr(A) SLE expr(B). { PROTECT { BV_CMPOP(bfvSlte, E, A, B) } }
expr(E) ::= expr(A) GT expr(B). { PROTECT { BV_INVCMPOP(bfvUlte, E, A, B) } }
expr(E) ::= expr(A) GE expr(B). { PROTECT { BV_INVCMPOP(bfvUlt, E, A, B) } }
expr(E) ::= expr(A) SGT expr(B). { PROTECT { BV_INVCMPOP(bfvSlte, E, A, B) } }
expr(E) ::= expr(A) SGE expr(B). { PROTECT { BV_INVCMPOP(bfvSlt, E, A, B) } }
expr(E) ::= NOT expr(A). { PROTECT { E = bap_val_new_bv(bfvInvert(MS->bf, BV(A))); bap_val_unref(MS, A); } }
expr(E) ::= MINUS expr(A). [UMINUS] { PROTECT { E = bap_val_new_bv(bfvNegate(MS->bf, BV(A))); bap_val_unref(MS, A); } }
expr(E) ::= UNKNOWN STRING COLON typ(T). { PROTECT { E = bap_val_new_bot(T); } }
expr(E) ::= STRING(A). { PROTECT { E = bap_val_new_string(A->ident); } }
expr(E) ::= lval(V). { PROTECT { E = bap_lookup_ident(MS, V.name, V.typ); free (V.name); } }
expr(E) ::= IF expr(C) THEN expr(T) ELSE expr(F). { PROTECT { if (!(IS_BV(C) && IS_BV(T) && (IS_BV(F)))) { ERROR("ITE arguments are not bvs"); } else { E = bap_val_new_bv(bfvSelect(MS->bf, BV(C)->data[0], BV(T), BV(F))); bap_val_unref(MS, C); bap_val_unref(MS, T); bap_val_unref(MS, F); } } }
expr(E) ::= letstart(L) IN expr(A). { PROTECT { bap_clear_binding(MS, L.name); if (L.val != NULL) { bap_set_binding(MS, L.name, L.val); } bap_val_unref(MS, L.val); free(L.name); E = A; } }
expr(E) ::= EXTRACT COLON INT(H) COLON INT(L) COLON LSQUARE expr(A) RSQUARE. { PROTECT { if (!IS_BV(A)) { ERROR("EXTRACT arguments are not bvs"); } else { E = bap_val_new_bv(bfvExtract(MS->bf, BV(A), L->i, H->i-L->i)); bap_val_unref(MS, A); } } }
expr(E) ::= CONCAT COLON LSQUARE expr(L) RSQUARE LSQUARE expr(R) RSQUARE.  { PROTECT { if (!(IS_BV(L) && IS_BV(R))) { ERROR("CONCAT arguments are not bvs"); } else { E = bap_val_new_bv(bfvConcat(MS->bf, BV(L), BV(R))); bap_val_unref(MS, L); bap_val_unref(MS, R); } } }
expr(E) ::= ID(F) COLON typ(T) LPAREN expr(A) RPAREN. { PROTECT { E = do_function(MS, F->ident, T, A); bap_val_unref(MS, A); } destroy_token(F); }
expr(E) ::= TRUE. { E = bap_val_new_bv(bfvUconstant(MS->bf, 1, 1)); }
expr(E) ::= FALSE. { E = bap_val_new_bv(bfvUconstant(MS->bf, 1, 0)); }
expr(E) ::= INT(I) COLON typ(T). { PROTECT { if (T.kind != BAP_TYPE_KIND_BV) { ERROR("Constant type is not a bv"); } else { E = bap_val_new_bv(bfvUconstant(MS->bf, T.val_width, I->i)); } } destroy_token(I); }
expr(E) ::= expr(M) WITH(W) LSQUARE expr(I) COMMA endian(BE) RSQUARE COLON typ assign expr(V). [WITH] { PROTECT { if (!(IS_ARRAY(M) && IS_BV(V) && IS_BV(I))) { ERROR("STORE arguments not right types"); } else { memory *m = bfmCopy(MS->bf, ARRAY(M)); if (BE) { bfmStore_be(MS->bf, m, BV(I), BV(V)); } else { bfmStore_le(MS->bf, m, BV(I), BV(V)); } E = bap_val_new_array(m); bap_val_unref(MS, M); bap_val_unref(MS, I); bap_val_unref(MS, V); destroy_token(W); } } }
expr(E) ::= expr(M) LSQUARE expr(I) COMMA endian(BE) RSQUARE COLON typ(T). { PROTECT { if (!(IS_ARRAY(M) && IS_BV(I) && T.kind == BAP_TYPE_KIND_BV)) { ERROR("LOAD types not right"); } else { bitvec *v; if (BE) { v = bfmLoad_be(MS->bf, ARRAY(M), BV(I), T.val_width / bfmEltSize(ARRAY(M))); } else { v = bfmLoad_le(MS->bf, ARRAY(M), BV(I), T.val_width / bfmEltSize(ARRAY(M))); } E = bap_val_new_bv(v); bap_val_unref(MS, M); bap_val_unref(MS, I); } } }

%type endian { bool }

endian(BE) ::= EBIG. { BE = true; } 
endian(BE) ::= ELITTLE. { BE = false; }
endian ::= expr. { ERROR("Endian as expression not supported\n"); }

semi ::= SEMI. { }
semi ::= . { }

assign ::= ASSIGN. { }
assign ::= EQUAL. { }
