from bitfunc.expdag import *
from bitfunc import BF_SAT, BF_UNSAT, BF_UNKNOWN
import bitfunc
from sys import stderr
import random
import bitfunc.qc as qc

def constexps(low=-1024, high=1024, width=32):
  """
  endlessly generate ConstExps from constants between `low' and `high'
  """
  yield ConstExp(low, width)
  yield ConstExp(high, width)
  while True:
    const = random.randint(low, high)
    yield ConstExp(const, width)

def binexps_exact_height(cls, height, leaves=constexps()):
  assert height >= 0
  if height == 0:
    while True:
      yield leaves.next()
  else:
    genbools = qc.bools()
    genkids = binexps_exact_height(cls, random.randint(0, height-1), leaves=leaves)
    while True:
      l = leaves.next()           # height 0
      for _ in xrange(height):
        # randomly pick leaf or tree for right branch
        if genbools.next(): r = genkids.next()
        else: r = leaves.next()
        # randomly swap branches so trees don't prefer unbalancing
        if genbools.next():
          l = cls(r,l)
        else:
          l = cls(l,r)
      yield l


def binexps(cls, low=0, high=10, leaves=constexps()):
  """
  endlessly generate `cls' binary trees of height between `low' and `high' using
  leaves generated by `leaves'. it must be: 0 <= `low' <= `high'

  the implementation should uniformly distribute over trees of height between
  `low' and `high'
  """
  assert 0 <= low <= high
  
  gens = qc.oneof([binexps_exact_height(cls, i, leaves=leaves) for i in xrange(low, high+1)])
  while True:
    yield gens.next()

gensubexps = binexps(SubExp, high=10)
# for i in xrange(5):
#   with open('addexp-%d.dot' % i, 'w') as fd:
#     as_dot_nodes({genaddexps.next(): 'root'}, fd, number_edges=False)
        

x = ConstExp(3)
assert x.width == 2
x = ConstExp(-3)
assert x.width == 3

x = c1 = ConstExp(3)
assert 2 == len(x)
# print >>stderr, 'x.threeval = %s' % x.threeval
# assert x.threeval == '11'

x = c2 = ConstExp(-23)
assert 6 == len(x)
# print >>stderr, 'x.threeval = %s' % x.threeval
assert len(x) == len(x.threeval)
assert ''.join(x.threeval) == '101001'

c = ConcatExp(ConstExp(3), UnknownExp(width=25))
assert len(c)==27

# test some structural hashing
c1 = ConstExp(3, width=32)
c2 = ConstExp(28, width=32)
assert ''.join(c1.threeval) == '00000000000000000000000000000011'
assert ''.join(c2.threeval) == '00000000000000000000000000011100'
a = AddExp(c1, c2)
s = SubExp(c1, c2)
assert hash(a) != hash(s)

c1 = ConstExp(3, width=32)
c2 = ConstExp(3, width=31)
assert c1 is not c2

a1 = AddExp(c1, ZExtExp(c2, 32))
a2 = AddExp(c1, ZExtExp(c2, 32))
assert type(a1) == type(a2)
assert a1 is a2
assert a1 == a2

c1 = ConstExp(-4, width=32)
assert ''.join(c1.threeval) == '11111111111111111111111111111100'
c2 = ConstExp(12, width=32)
a1 = AddExp(c1, c2)
a2 = AddExp(c1, c2)
assert type(a1) == type(a2)
assert a1 == a2
assert a1 is a2

u1 = UnknownExp(32)
u2 = UnknownExp(32)
assert u1 != u2
assert u1 is not u2

u1 = InputExp(32)
u2 = InputExp(32)
assert u1 != u2
assert u1 is not u2

c1 = ConcatExp(ConstExp(3),
                  ConcatExp(ConstExp(3),
                               ConcatExp(ConstExp(3), ConstExp(3))))
assert len(c1)==8
c2 = ConcatExp(ConstExp(3),
                  ConcatExp(ConstExp(3),
                               ConcatExp(ConstExp(3), ConstExp(3))))
assert c1 is c2

print hash(type(c))
print hash(type(c))

iz=mkIsZero(c1)

ip=mkIsPos(c1)
ip2=mkIsPos(c1, signed=True)

# assert len(x) == 8
# with open('test.dot', 'w') as fd:
#   fd.write(ExpDagBase.as_dot_nodes([x], number_edges=False))
print ip2.as_dot()

def uconst(x):
  return ConstExp(x, width=32)
def sconst(x):
  return ConstExp(x, width=32)

BF = bitfunc.bfman()
bitfunc.expdag.BF = BF
print uconst(3).as_bitvec({})
print uconst(3).as_bitvec({}).bin
print sconst(-3).as_bitvec({})
print sconst(-3).as_bitvec({}).bin
e = AddExp(uconst(3), uconst(3)).as_bitvec({}).uint
print '3+3 = %u' % e
assert e==6
e = SubExp(uconst(12), uconst(7)).as_bitvec({}).int
print '12-7 = %d' % e
assert e==5
e = MulExp(uconst(14), uconst(2)).as_bitvec({}).uint
print '14*2 = %u' % e
assert e==28
e = MulExp(uconst(14), sconst(-2)).as_bitvec({})
print '14*-2 = %d' % e.int
assert e.int==-28
e = MulExp(uconst(7), sconst(-7))
e = MulExp(e, uconst(7)).as_bitvec({}).int
print '7*-7*7 = %d' % e
assert e == -343
e = uconst(28).as_bitvec({})
print '%s' % e.bin
e = LShrExp(uconst(28), uconst(1)).as_bitvec({})
print '%s = 28 >> 1' % e.bin
assert e.uint == (28>>1)
e = uconst(28).as_bitvec({})
print '%s' % e.bin
e = LShrExp(uconst(28), uconst(3)).as_bitvec({})
assert e.uint == (28>>3)
print '%s = 28 >> 3' % e.bin
e = sconst(-28).as_bitvec({})
print '%s' % e.bin
e = LShrExp(sconst(-28), uconst(1)).as_bitvec({})
print '%s = -28 >> 1' % e.bin

e = AShrExp(uconst(28), uconst(3)).as_bitvec({})
assert e.uint==(28>>3)
e = AShrExp(sconst(-28), uconst(3)).as_bitvec({})
print '%s = -28 a>> 3' % e.bin
assert e.int==(-28>>3)

def popcnt(ebx):
  # popcnt function, ebx is the input
  eax = ebx
  eax = AndExp(eax, uconst(0x55555555))
  ebx = LShrExp(ebx, uconst(1))
  ebx = AndExp(ebx, uconst(0x55555555))
  ebx = AddExp(ebx, eax)
  eax = ebx
  eax = AndExp(eax, uconst(0x33333333))
  ebx = LShrExp(ebx, uconst(2))
  ebx = AndExp(ebx, uconst(0x33333333))
  ebx = AddExp(ebx, eax)
  eax = ebx
  eax = AndExp(eax, uconst(0x0F0F0F0F))
  ebx = LShrExp(ebx, uconst(4))
  ebx = AndExp(ebx, uconst(0x0F0F0F0F))
  ebx = AddExp(ebx, eax)
  eax = ebx
  eax = AndExp(eax, uconst(0x00FF00FF))
  ebx = LShrExp(ebx, uconst(8))
  ebx = AndExp(ebx, uconst(0x00FF00FF))
  ebx = AddExp(eax, ebx)
  eax = ebx
  eax = AndExp(eax, uconst(0x0000FFFF))
  ebx = LShrExp(ebx, uconst(16))
  ebx = AndExp(ebx, uconst(0x0000FFFF))
  ebx = AddExp(ebx, eax)
  eax = ebx
  return eax

ebx_in = InputExp(32)
eax = popcnt(ebx_in)

with open('test.dot', 'w') as fd:
  as_dot_nodes({eax: 'eax'}, fd, number_edges=False)

result = eax.as_bitvec({ebx_in: BF.vUconstant(32, 0)})
print 'popcnt(0) = %u' % result.uint
assert result.uint == 0

result = eax.as_bitvec({ebx_in: BF.vUconstant(32, 1)})
print 'popcnt(1) = %u' % result.uint
assert result.uint == 1

result = eax.as_bitvec({ebx_in: BF.vUconstant(32, 0xff00)})
print 'popcnt(0xff00) = %u' % result.uint
assert result.uint == 8

x = uconst(18)
xi = InvertExp(x)
xii = InvertExp(xi)
print '18 = %s' % x.as_bitvec().bin
print '~18 = %s' % xi.as_bitvec().bin
print '~~18 = %s' % xii.as_bitvec().bin
assert xii.as_bitvec()==x.as_bitvec()

# solve some stuff using popcnt example and the new expdag API
BF = bitfunc.bfman()
bitfunc.expdag.BF = BF
ebx_in = InputExp(32)
ebx_in_bv = BF.vInit(32)
input_map = {ebx_in: ebx_in_bv}
eax = popcnt(ebx_in)

eax_bv = eax.as_bitvec(input_map)
eax_is_1 = EqExp(uconst(1), eax)
eax_is_1_bv = eax_is_1.as_bitvec(input_map)
print 'can popcnt (eax) be 1? (should be sat)'
if BF_UNSAT == BF.pushAssumption(eax_is_1_bv[0]):
  print "trivially unsat"
  assert False
else:
  res = BF.solve()
  print 'result: %s' % str(res)
  assert res == BF_SAT
  print 'ebx: %s' % BF.vFromCounterExample(ebx_in_bv)

print 'can eax by 1 if ebx is 0? (should be unsat)'
ebx_is_0 = EqExp(uconst(0), ebx_in)
if BF_UNSAT == BF.pushAssumption(ebx_is_0.as_bitvec(input_map)[0]):
  print "trivially unsat"
else:
  res = BF.solve()
  print 'result: %s' % str(res)
  assert res == BF_UNSAT

# test really large constants
x = ConstExp(0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffe)
x_bv = x.as_bitvec()
print x
assert len(x_bv) == len(x)

x = ConstExp(-0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffe)
x_bv = x.as_bitvec()
print x
assert len(x_bv) == len(x)


def uaddr(x):
  return ConstExp(x, width=32)
def uvalu(x):
  return ConstExp(x, width=8)
a = Array(32, 8, base=0x7ffff, length=0x100)
u = VanillaUpdateGroup(a)
u.update(uaddr(a.base+0xa), uvalu(0x28))
u.update(uaddr(a.base+0xb), uvalu(0x29))
assert u.next is None
u2 = u.with_update(uaddr(a.base+0xc), uvalu(0x30))
assert u2.next is u
u2.update(uaddr(a.base+0xc), uvalu(0x31))
x = u2.read(uaddr(a.base+0xa))
with open('test.dot', 'w') as fd:
  as_dot_nodes({x: 'x'}, fd)

# x = a.read(0xff)
# print x

y = uconst(12)
inner = InvertExp(y)
x = InvertExp(inner)
assert x is y
x = InvertExp(x)
assert x is InvertExp(y)

cxt = RewriteContext(rewrite_recursive_max_depth=0)
try:
  with cxt:
    print 'hi'
    assert False
except RewriteBoundExceeded:
  pass

def addexps(xs):
  return reduce(lambda x,y: AddExp(x,y), xs, zero(32))
def const(x):
  return ConstExp(x, width=32)
cxt = RewriteContext()

x = const(12)
y = const(12)
rw = AddExp.rewrite(cxt, x, y)
assert rw == const(24)
x = const(-12)
y = const(12)
rw = AddExp.rewrite(cxt, x, y)
assert rw == const(0)
x = const(1028)
y = const(700)
rw = AddExp.rewrite(cxt, x, y)
assert rw == const(1028+700)

x = const(1028)
y = const(700)
rw = SubExp.rewrite(cxt, x, y)
assert rw == const(1028-700)


print >>stderr, 'testing AddExp rewriting'

x = addexps([const(12), const(27), const(0x100), const(-32), const(18),
             const(-12), const(100)])
y = addexps([const(12), const(27), const(-0x100), const(-32), const(18),
             const(-12), const(17)])
z = AddExp.normalize_comm_ass(cxt, x, y)
assert z == const(12+27+0x100-32+18-12+100+12+27-0x100-32+18-12+17)
with open('test.dot', 'w') as fd:
  as_dot_nodes({z: 'z'}, fd)
print str(z)

genaddexps = binexps(AddExp, low=0, high=6)

x = ConstExp(0b100, 3)
y = ReverseExp(x)
z = ReverseExp.rewrite(cxt, y)
assert z == ConstExp(0b001, 3)

